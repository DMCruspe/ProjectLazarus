'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.join = join;
exports.linkify = linkify;
exports.delinkify = delinkify;
exports.graph = graph;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _jsonPointer = require('json-pointer');

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _mongodb = require('mongodb');

var _utils = require('../utils');

var internals = {};

internals.idFromUrl = function (url) {

  if (!url) {
    return undefined;
  }

  url = url.split('/');
  var id = url[url.length - 1];

  try {
    return new _mongodb.ObjectId(id);
  } catch (error) {}
};

internals.copy = function (from, to, dontCopy) {

  dontCopy = new RegExp('^' + dontCopy.map(function (pointer) {
    return _lodash2['default'].escapeRegExp(pointer);
  }).join('|'));

  _lodash2['default'].each(_jsonPointer2['default'].dict(from), function (value, pointer) {
    // We are using a bad property, don't copy
    if (dontCopy.test(pointer)) {
      return;
    }
    _jsonPointer2['default'].set(to, pointer, value);
  });
};

function join(pointer, model) {
  var _this = this;

  if (_lodash2['default'].isObject(pointer)) {
    _lodash2['default'].each(pointer, function (m, p) {
      return join.call(_this, p, m);
    });
    return;
  }

  // Allows the passage of a model instance
  if (!model) {
    throw new Error('A model is not defined');
  }
  if (!this._joins) {
    this._joins = {};
  }

  this._joins[pointer] = model;
}

function linkify(document, onLink) {

  var linkedDocument = { '@id': this.getUrl(document._id) };
  var dontCopy = ['/_id'];

  _lodash2['default'].each(this._joins, function (model, pointer) {
    // If the pointed value does not exist end
    if (!_jsonPointer2['default'].has(document, pointer)) {
      return;
    }
    var id = _jsonPointer2['default'].get(document, pointer);

    // If the value is not an id, it is not what we want
    if (!(id instanceof _mongodb.ObjectId)) {
      return;
    }

    // Output the json-ld style reference
    _jsonPointer2['default'].set(linkedDocument, pointer, { '@id': model.getUrl(id) });

    // Let's not copy that again, then call the callback
    dontCopy.push(pointer);
    onLink(model, id);
  });

  internals.copy(document, linkedDocument, dontCopy);

  return linkedDocument;
}

function delinkify(linkedDocument) {

  var document = { _id: internals.idFromUrl(linkedDocument['@id']) };
  var dontCopy = ['/@id'];

  _lodash2['default'].each(this._joins, function (model, pointer) {

    if (!_jsonPointer2['default'].has(document, pointer)) {
      return;
    }
    var url = _jsonPointer2['default'].get(document, pointer)['@id'];
    if (!url) {
      return;
    }
    _jsonPointer2['default'].set(linkedDocument, pointer, internals.idFromUrl(url));
    dontCopy.push(pointer);
  });

  internals.copy(linkedDocument, document, dontCopy);

  return document;
}

// TODO: STREAMIFY
// TODO: STREAMIFY
// TODO: STREAMIFY
// TODO: STREAMIFY
// TODO: STREAMIFY
// TODO: STREAMIFY
// TODO: STREAMIFY
// TODO: STREAMIFY
// TODO: STREAMIFY

function graph() {

  var args = _lodash2['default'].toArray(arguments);
  var callback = _lodash2['default'].once((0, _utils.getCallback)(args) || _assert2['default'].ifError);
  var selector = args.shift() || {};
  var options = args.shift() || {};

  var theGraph = [];
  var waitingOn = 0;

  function next(error) {

    if (error) {
      return callback(error);
    }
    waitingOn--;
    if (waitingOn === 0) {
      callback(null, theGraph);
    }
  }

  function fetch(document) {

    var linkedDocument = document.linkify(function (model, id) {

      // Increment waiting on
      waitingOn++;

      model.findOne({ _id: id }, function (error, joinedDocument) {

        if (error) {
          return next(error);
        }
        // If the document was not found
        if (!joinedDocument) {
          return next();
        }
        // Run the fetch command on the new document
        fetch(joinedDocument);
      });
    });

    theGraph.push(linkedDocument);
    next();
  }

  this.find(selector, options, function (error, documents) {

    if (error) {
      return callback(error);
    }
    waitingOn += documents.length;
    documents.forEach(fetch);
  });
}

/* Silence */